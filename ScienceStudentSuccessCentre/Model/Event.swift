//
//  Event.swift
//  ScienceStudentSuccessCentre
//
//  Created by Avery Vine on 2018-01-31.
//  Copyright Â© 2018 Avery Vine. All rights reserved.
//

import Foundation

/// Encompass all of the details for an SSSC event.
///
/// - Attention: You should never have to generate these yourself, as event generation is handled by the server.
class Event {
    private let urlPrefix = "https://sssc.carleton.ca"
    
    private var id: String
    private var name: String
    private var description: String
    private var dateTime: Date?
    private var rawTime: String
    private var location: String
    private var url: URL?
    private var imageUrl: URL?
    private var actionUrl: String?
    
    private let calendar = Calendar.current
    
    /// Initializes an event based off a dictionary of data provided by the server.
    ///
    /// - Parameter eventData: The data parsed and generated by the server for this event.
    required convenience init(eventData: NSDictionary) {
        let id = eventData["id"] as! String
        let name = eventData["name"] as! String
        let description = eventData["description"] as! String
        let dateTimeWithMillis = eventData["dateTime"] as! String
        let dateTimeNoFormatting = dateTimeWithMillis.replacingOccurrences(of: "\\.\\d+", with: "", options: .regularExpression)
        let dateTime = Formatter.iso8601.date(from: dateTimeNoFormatting)
        let rawTime = eventData["rawTime"] as! String
        
        let location = eventData["location"] as! String
        
        let url: URL?
        if let urlString = eventData["url"] as? String, urlString != "" {
            url = URL(string: urlString)
        } else {
            url = nil
        }
        
        let imageUrl: URL?
        if let imageUrlString = eventData["imageUrl"] as? String, imageUrlString != "" {
            imageUrl = URL(string: imageUrlString)
        } else {
            imageUrl = nil
        }
        
        let actionUrl = eventData["actionUrl"] as? String
        
        self.init(id: id, name: name, description: description, dateTime: dateTime, rawTime: rawTime, location: location, url: url, imageUrl: imageUrl, actionUrl: actionUrl)
    }
    
    private init(id: String, name: String, description: String, dateTime: Date?, rawTime: String, location: String, url: URL?, imageUrl: URL?, actionUrl: String?) {
        self.id = id
        self.name = name
        self.description = description
        self.dateTime = dateTime
        self.rawTime = rawTime
        self.location = location
        self.url = url
        self.imageUrl = imageUrl
        self.actionUrl = actionUrl
    }

    
    /// Gets the id of the event.
    ///
    /// - Remark: Note that this id can technically not be unique (as it is just whatever is sent by the server), but should be treated as such.
    /// - Returns: The id of the event.
    public func getId() -> String {
        return id
    }
    
    
    /// Gets the name of the event.
    ///
    /// - Returns: The name of the event.
    public func getName() -> String {
        return name
    }
    
    public func getDescription() -> String {
        return description
    }
    
    /// Provides the start date and time of this event.
    ///
    /// - Remark: For the date and time that users should receive a notification for this event, use `getNotificationDateTime()`.
    /// - Returns: The event start date and time, or `nil` if the server could not provide one.
    public func getDateTime() -> Date? {
        return dateTime
    }
    
    public func getFormattedDateAndTime() -> String {
        var formattedDateAndTime = getMonthName() + " " + getDayLeadingZero()
        if getRawTime() != "" {
            formattedDateAndTime += "\n" + getRawTime()
        }
        return formattedDateAndTime
    }
    
    /// Provides the date and time the user should receive a notification for this event.
    ///
    /// - Remark: For the actual date and time of this event, use `getDateTime()`.
    /// - Returns: The notification date and time, or `nil` if one could not be calculated.
    public func getNotificationDateTime() -> Date? {
        if let dateTime = dateTime {
            return calendar.date(byAdding: .hour, value: -1, to: dateTime)
        }
        return nil
    }
    
    
    /// Gets the year of the event.
    ///
    /// - Returns: The year of the event.
    public func getYear() -> Int {
        return calendar.component(.year, from: dateTime!)
    }
    
    
    /// Gets the month of the event, as a 3-letter string.
    ///
    /// - Remark: To get the month as a number, use the corresponding function `getMonth()`.
    /// - Returns: The month of the event.
    public func getMonthName() -> String {
        let months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
        return months[getMonth() - 1]
    }
    
    
    /// Gets the month of the event, as an integer.
    ///
    /// - Remark: To get the month as a 3-letter string, use the corresponding function `getMonthName()`.
    /// - Returns: The month of the event.
    public func getMonth() -> Int {
        return calendar.component(.month, from: dateTime!)
    }
    
    
    /// Gets the day of the event, as an integer.
    ///
    /// - Remark: For a formatted day (with leading zero), use the corresponding function `getDayLeadingZero()`.
    /// - Returns: The day of the event.
    public func getDay() -> Int {
        return calendar.component(.day, from: dateTime!)
    }
    
    /// Gets the day of this event, formatted with a leading zero.
    ///
    /// - Remark: For an unformatted day (as an integer), use the corresponding function `getDay()`.
    /// - Returns: The day of the event.
    public func getDayLeadingZero() -> String {
        let day: Int = getDay()
        if (day < 10) {
            return "0" + String(day)
        }
        return String(day)
    }
    
    /// Gets the unparsed event time as provided by the server.
    ///
    /// - Remark: There are alternative ways to get the time that should probably be preferred (`getFormattedTime()`, `getDateTime()`).
    /// - Returns: Unparsed time, as provided by the server (which in turn, is unparsed directly from the website).
    public func getRawTime() -> String {
        return rawTime
    }
    
    
    /// Formats the event time for quick summarization, based off the parsed Date object.
    ///
    /// - Returns: The formatted event time.
    public func getFormattedTime() -> String {
        let formatter = DateFormatter()
        formatter.timeStyle = .medium
        formatter.amSymbol = "am"
        formatter.pmSymbol = "pm"
        formatter.dateFormat = "HH:mm"
        let formattedTime = formatter.date(from: formatter.string(from: dateTime!))
        formatter.dateFormat = "h:mma"
        return formatter.string(from: formattedTime!)
    }
    
    
    /// Gets the location of the event (most likely just the building and room number).
    ///
    /// - Returns: The location of the event.
    public func getLocation() -> String {
        return location
    }
    
    /// Gets the complete URL of the event, including the domain name portion.
    ///
    /// - Returns: The complete event URL, or `nil` if there one could not be found.
    public func getUrl() -> URL? {
        if let url = url {
            return URL(string: urlPrefix + url.absoluteString)
        }
        return nil
    }
    
    
    /// Gets the URL of the first image associated with this event.
    ///
    /// - Returns: The image URL, or `nil` if there isn't one associated with this event.
    public func getImageUrl() -> URL? {
        return imageUrl
    }
    
    
    /// Gets the URL that users can "act on" (click to RSVP, sign up on Carleton Central, etc).
    ///
    /// - Returns: The action URL, or `nil` if there isn't one associated with this event.
    public func getActionUrl() -> String? {
        return actionUrl
    }
    
    public static func generateTestEvent() -> Event {
        return Event(id: "12345",
                     name: "Test Event",
                     description: "This is a test description. It is very long and repeats itself. This is a test description. It is very long and repeats itself. This is a test description. It is very long and repeats itself.",
                     dateTime: Date(),
                     rawTime: "5pm",
                     location: "3431 Herzberg",
                     url: nil,
                     imageUrl: nil,
                     actionUrl: "https://central.carleton.ca")
    }
    
    public static func generateTestEvent2() -> Event {
        return Event(id: "67890",
                     name: "Test Event 2",
                     description: "Description description description description description description description description description description.",
                     dateTime: Date(timeInterval: TimeInterval(integerLiteral: 86400), since: Date()),
                     rawTime: "2:00pm - 3:00pm",
                     location: "3431 Herzberg",
                     url: URL(string: "https://sssc.carleton.ca/sites/default/files/inline-images/Roxy.jpg")!,
                     imageUrl: URL(string: "https://sssc.carleton.ca/sites/default/files/inline-images/Roxy.jpg"),
                     actionUrl: nil)
    }
}
